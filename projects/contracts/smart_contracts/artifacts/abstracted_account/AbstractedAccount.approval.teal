#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 20 25 192
    bytecblock "p" "admin" "controlled_address" 0x00 0x001b 0x0000000000000000 "n" 0x0f885493 0x151f7c75 0x0000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txn NumAppArgs
    bz main_after_if_else@19
    pushbytess 0xb4c77d71 0xd24b7556 0x5fa449c6 0x13bc44e4 // method "createApplication(address,address)void", method "arc58_changeAdmin(address)void", method "arc58_pluginChangeAdmin(uint64,address,address)void", method "arc58_getAdmin()address"
    bytec 7 // method "arc58_verifyAuthAddr()void"
    pushbytess 0xc95a5d3d 0x7699308f 0x3f8615d7 0x5c34f3d6 0x0a8a19d4 0x4d372355 0xea8bb9ec 0xe350b9d4 // method "arc58_rekeyTo(address,bool)void", method "arc58_canCall(uint64,address,byte[4])bool", method "arc58_rekeyToPlugin(uint64,uint64[])void", method "arc58_rekeyToNamedPlugin(string,uint64[])void", method "arc58_addPlugin(uint64,address,uint64,uint64,bool,(byte[4],uint64)[])void", method "arc58_removePlugin(uint64,address)void", method "arc58_addNamedPlugin(string,uint64,address,uint64,uint64,bool,(byte[4],uint64)[])void", method "arc58_removeNamedPlugin(string)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_arc58_changeAdmin_route@4 main_arc58_pluginChangeAdmin_route@5 main_arc58_getAdmin_route@6 main_arc58_verifyAuthAddr_route@7 main_arc58_rekeyTo_route@8 main_arc58_canCall_route@9 main_arc58_rekeyToPlugin_route@10 main_arc58_rekeyToNamedPlugin_route@11 main_arc58_addPlugin_route@12 main_arc58_removePlugin_route@13 main_arc58_addNamedPlugin_route@14 main_arc58_removeNamedPlugin_route@15

main_after_if_else@19:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    intc_0 // 0
    return

main_arc58_removeNamedPlugin_route@15:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:567
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:567
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    callsub arc58_removeNamedPlugin
    intc_1 // 1
    return

main_arc58_addNamedPlugin_route@14:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:527-535
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:527-535
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    callsub arc58_addNamedPlugin
    intc_1 // 1
    return

main_arc58_removePlugin_route@13:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:505
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:505
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    callsub arc58_removePlugin
    intc_1 // 1
    return

main_arc58_addPlugin_route@12:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:467-474
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:467-474
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    callsub arc58_addPlugin
    intc_1 // 1
    return

main_arc58_rekeyToNamedPlugin_route@11:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:451
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:451
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    callsub arc58_rekeyToNamedPlugin
    intc_1 // 1
    return

main_arc58_rekeyToPlugin_route@10:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:427
    // arc58_rekeyToPlugin(plugin: arc4.UintN64, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:427
    // arc58_rekeyToPlugin(plugin: arc4.UintN64, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    callsub arc58_rekeyToPlugin
    pop
    intc_1 // 1
    return

main_arc58_canCall_route@9:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:410
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:410
    // @abimethod({ readonly: true })
    callsub arc58_canCall
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 8 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_rekeyTo_route@8:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:385
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:385
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    callsub arc58_rekeyTo
    intc_1 // 1
    return

main_arc58_verifyAuthAddr_route@7:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:375
    // arc58_verifyAuthAddr(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_verifyAuthAddr
    intc_1 // 1
    return

main_arc58_getAdmin_route@6:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:367
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub arc58_getAdmin
    bytec 8 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_arc58_pluginChangeAdmin_route@5:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:343
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:343
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    callsub arc58_pluginChangeAdmin
    intc_1 // 1
    return

main_arc58_changeAdmin_route@4:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:329
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:329
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    callsub arc58_changeAdmin
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:308
    // @abimethod({ onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:7
    // export class AbstractedAccount extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:308
    // @abimethod({ onCreate: 'require' })
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.pluginCallAllowed(app: bytes, caller: bytes, method: bytes) -> uint64:
pluginCallAllowed:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:25
    // private pluginCallAllowed(app: arc4.UintN64, caller: arc4.Address, method: arc4.StaticBytes<4>): boolean {
    proto 3 1
    intc_0 // 0
    dup
    pushbytes ""
    dupn 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:26
    // const key = new PluginsKey({ application: app, allowedCaller: caller });
    frame_dig -3
    frame_dig -2
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    swap
    concat
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:28
    // if (!this.plugins(key).exists) {
    box_len
    bury 1
    bnz pluginCallAllowed_after_if_else@2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:29
    // return false;
    intc_0 // 0
    frame_bury 0
    retsub

pluginCallAllowed_after_if_else@2:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:32
    // const methods = this.plugins(key).value.methods.copy();
    frame_dig 5
    box_get
    assert // Box must have value
    dup
    intc_3 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:33
    // let methodAllowed = methods.length > 0 ? false : true;
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 4
    !
    frame_bury 3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:34
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0
    frame_bury 2

pluginCallAllowed_while_top@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:34
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    frame_dig 4
    <
    bz pluginCallAllowed_block@8
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:35
    // if (methods[i].selector === method) {
    frame_dig 0
    extract 2 0
    frame_dig 2
    intc_2 // 20
    *
    intc_2 // 20
    extract3 // on error: Index access is out of bounds
    extract 0 4 // on error: Index access is out of bounds
    frame_dig -1
    ==
    bz pluginCallAllowed_after_if_else@6
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:36
    // methodAllowed = true;
    intc_1 // 1
    frame_bury 3

pluginCallAllowed_block@8:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:41
    // const p = this.plugins(key).value.copy();
    frame_dig 5
    box_get
    swap
    dup
    cover 2
    frame_bury 1
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:43
    // p.lastValidRound.native >= Global.round
    intc_0 // 0
    extract_uint64
    global Round
    >=
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:43-44
    // p.lastValidRound.native >= Global.round
    // && (Global.round - p.lastCalled.native) >= p.cooldown.native
    bz pluginCallAllowed_bool_false@11
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:44
    // && (Global.round - p.lastCalled.native) >= p.cooldown.native
    global Round
    frame_dig 1
    dup
    cover 2
    pushint 16 // 16
    extract_uint64
    -
    swap
    pushint 8 // 8
    extract_uint64
    >=
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:43-44
    // p.lastValidRound.native >= Global.round
    // && (Global.round - p.lastCalled.native) >= p.cooldown.native
    bz pluginCallAllowed_bool_false@11
    intc_1 // 1

pluginCallAllowed_bool_merge@12:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:43-45
    // p.lastValidRound.native >= Global.round
    // && (Global.round - p.lastCalled.native) >= p.cooldown.native
    // && methodAllowed
    frame_dig 3
    &&
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:42-46
    // return (
    //   p.lastValidRound.native >= Global.round
    //   && (Global.round - p.lastCalled.native) >= p.cooldown.native
    //   && methodAllowed
    // );
    frame_bury 0
    retsub

pluginCallAllowed_bool_false@11:
    intc_0 // 0
    b pluginCallAllowed_bool_merge@12

pluginCallAllowed_after_if_else@6:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:34
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig 2
    intc_1 // 1
    +
    frame_bury 2
    b pluginCallAllowed_while_top@3


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.txnRekeysBack(txn: uint64) -> uint64:
txnRekeysBack:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:49
    // private txnRekeysBack(txn: gtxn.Transaction): boolean {
    proto 1 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:50
    // if (txn.sender === Global.currentApplicationAddress && txn.rekeyTo === Global.currentApplicationAddress) {
    frame_dig -1
    gtxns Sender
    global CurrentApplicationAddress
    ==
    bz txnRekeysBack_after_if_else@3
    frame_dig -1
    gtxns RekeyTo
    global CurrentApplicationAddress
    ==
    bz txnRekeysBack_after_if_else@3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:51
    // return true;
    intc_1 // 1
    retsub

txnRekeysBack_after_if_else@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55
    // txn.type === TransactionType.ApplicationCall
    frame_dig -1
    gtxns TypeEnum
    pushint 6 // 6
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55-56
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:56
    // && txn.appId === Global.currentApplicationId
    frame_dig -1
    gtxns ApplicationID
    global CurrentApplicationID
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55-56
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    bz txnRekeysBack_bool_false@9
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:57
    // && txn.numAppArgs === 1
    frame_dig -1
    gtxns NumAppArgs
    intc_1 // 1
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55-57
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    bz txnRekeysBack_bool_false@9
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:58
    // && txn.onCompletion === OnCompleteAction.NoOp
    frame_dig -1
    gtxns OnCompletion
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55-58
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    bnz txnRekeysBack_bool_false@9
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:59
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    frame_dig -1
    intc_0 // 0
    gtxnsas ApplicationArgs
    bytec 7 // method "arc58_verifyAuthAddr()void"
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:55-59
    // txn.type === TransactionType.ApplicationCall
    // && txn.appId === Global.currentApplicationId
    // && txn.numAppArgs === 1
    // && txn.onCompletion === OnCompleteAction.NoOp
    // && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    bz txnRekeysBack_bool_false@9
    intc_1 // 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:54-60
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub

txnRekeysBack_bool_false@9:
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:54-60
    // return (
    //   txn.type === TransactionType.ApplicationCall
    //   && txn.appId === Global.currentApplicationId
    //   && txn.numAppArgs === 1
    //   && txn.onCompletion === OnCompleteAction.NoOp
    //   && txn.appArgs(0) === methodSelector('arc58_verifyAuthAddr()void')
    // )
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.pluginCheck(key: bytes) -> uint64, uint64, uint64, uint64, uint64, uint64, bytes:
pluginCheck:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:77
    // private pluginCheck(key: PluginsKey): PluginValidation {
    proto 1 7
    pushbytes ""
    dupn 3
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    frame_dig -1
    concat
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:78
    // const exists = this.plugins(key).exists;
    box_len
    dup
    uncover 2
    pop
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:79
    // if (!exists) {
    bnz pluginCheck_after_if_else@2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:81
    // exists: false,
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:82
    // expired: true,
    intc_1 // 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:83-84
    // hasCooldown: true,
    // onCooldown: true,
    dupn 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:85
    // hasMethodRestrictions: false,
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:86
    // valid: false
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:80-87
    // return {
    //   exists: false,
    //   expired: true,
    //   hasCooldown: true,
    //   onCooldown: true,
    //   hasMethodRestrictions: false,
    //   valid: false
    // }
    frame_dig -1
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    retsub

pluginCheck_after_if_else@2:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:90
    // const expired = Global.round > this.plugins(key).value.lastValidRound.native;
    global Round
    frame_dig 4
    dup
    cover 2
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    >
    frame_bury 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:91
    // const hasCooldown = this.plugins(key).value.cooldown.native > 0;
    dup
    box_get
    assert // Box must have value
    pushint 8 // 8
    extract_uint64
    intc_0 // 0
    >
    frame_bury 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:92
    // const onCooldown = (Global.round - this.plugins(key).value.lastCalled.native) < this.plugins(key).value.cooldown.native;
    global Round
    dig 1
    box_get
    assert // Box must have value
    pushint 16 // 16
    extract_uint64
    -
    dig 1
    box_get
    assert // Box must have value
    pushint 8 // 8
    extract_uint64
    <
    frame_bury 3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:93
    // const hasMethodRestrictions = this.plugins(key).value.methods.length > 0;
    box_get
    assert // Box must have value
    dup
    intc_3 // 25
    extract_uint16
    dig 1
    len
    substring3
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    >
    frame_bury 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:95
    // const valid = exists && !expired && !onCooldown;
    frame_dig 5
    bz pluginCheck_bool_false@6
    frame_dig 0
    bnz pluginCheck_bool_false@6
    frame_dig 3
    bnz pluginCheck_bool_false@6
    intc_1 // 1

pluginCheck_bool_merge@7:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:97-104
    // return {
    //   exists,
    //   expired,
    //   hasCooldown,
    //   onCooldown,
    //   hasMethodRestrictions,
    //   valid
    // }
    frame_dig 5
    frame_dig 0
    frame_dig 1
    frame_dig 3
    frame_dig 2
    uncover 5
    frame_dig -1
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    uncover 12
    retsub

pluginCheck_bool_false@6:
    intc_0 // 0
    b pluginCheck_bool_merge@7


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.fullPluginCheck(key: bytes, txn: uint64, app: uint64, caller: bytes, methodOffsets: bytes, methodIndex: uint64) -> uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, uint64, bytes, bytes:
fullPluginCheck:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:107-114
    // private fullPluginCheck(
    //   key: PluginsKey,
    //   txn: gtxn.ApplicationCallTxn,
    //   app: Application,
    //   caller: Account,
    //   methodOffsets: arc4.DynamicArray<arc4.UintN64>,
    //   methodIndex: uint64
    // ): FullPluginValidation {
    proto 6 11
    intc_0 // 0
    dupn 2
    pushbytes ""
    dupn 7
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:115
    // const check = this.pluginCheck(key);
    frame_dig -6
    callsub pluginCheck
    frame_bury -6
    dup
    cover 6
    cover 6
    cover 5
    cover 4
    cover 3
    cover 2
    swap
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:117
    // if (!check.valid) {
    bnz fullPluginCheck_after_if_else@4
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:118-123
    // return {
    //   ...check,
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    frame_dig 16
    frame_dig 15
    frame_dig 14
    frame_dig 13
    frame_dig 12
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:120
    // methodAllowed: false,
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:121
    // methodHasCooldown: true,
    intc_1 // 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:122
    // methodOnCooldown: true
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:118-123
    // return {
    //   ...check,
    //   methodAllowed: false,
    //   methodHasCooldown: true,
    //   methodOnCooldown: true
    // }
    frame_dig 11
    frame_dig -6
    frame_dig -2
    frame_bury 10
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_after_if_else@4:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:127
    // methodAllowed: !check.hasMethodRestrictions,
    frame_dig 12
    dup
    !
    frame_bury 5
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:128
    // methodHasCooldown: false,
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:126-130
    // let methodCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 6
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:129
    // methodOnCooldown: false
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:126-130
    // let methodCheck: MethodValidation = {
    //   methodAllowed: !check.hasMethodRestrictions,
    //   methodHasCooldown: false,
    //   methodOnCooldown: false
    // }
    frame_bury 7
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:132
    // if (check.hasMethodRestrictions) {
    bz fullPluginCheck_after_if_else@6
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:133
    // assert(methodIndex < methodOffsets.length, 'malformed methodOffsets');
    frame_dig -2
    intc_0 // 0
    extract_uint16
    frame_dig -1
    >
    assert // malformed methodOffsets
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:134
    // methodCheck = this.methodCheck(txn, app, caller, methodOffsets[methodIndex].native);
    frame_dig -2
    extract 2 0
    frame_dig -1
    pushint 8 // 8
    *
    extract_uint64
    dup
    frame_bury 8
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:255
    // assert(len(txn.appArgs(0)) === 4, 'invalid method signature length');
    frame_dig -5
    intc_0 // 0
    gtxnsas ApplicationArgs
    dup
    len
    dup
    pushint 4 // 4
    ==
    assert // invalid method signature length
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:256
    // const selectorArg = new arc4.StaticBytes<4>(txn.appArgs(0));
    pushint 4 // 4
    ==
    assert // Length is 4
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:258
    // const key = new PluginsKey({ application: new arc4.UintN64(app.id), allowedCaller: new arc4.Address(caller) });
    frame_dig -4
    itob
    frame_dig -3
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:260
    // const methods = this.plugins(key).value.methods.copy()
    box_get
    assert // Box must have value
    dup
    intc_3 // 25
    extract_uint16
    dig 1
    len
    substring3
    dup
    frame_bury 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:261
    // const allowedMethod = methods[offset].copy();
    extract 2 0
    uncover 2
    intc_2 // 20
    *
    dup
    frame_bury 4
    intc_2 // 20
    extract3 // on error: Index access is out of bounds
    dup
    frame_bury 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:263
    // const hasCooldown = allowedMethod.cooldown.native > 0;
    dup
    pushint 4 // 4
    extract_uint64
    dup
    frame_bury 10
    dup
    intc_0 // 0
    >
    frame_bury 3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:264
    // const onCooldown = (Global.round - allowedMethod.lastCalled.native) < allowedMethod.cooldown.native;
    global Round
    dig 2
    pushint 12 // 12
    extract_uint64
    -
    >
    frame_bury 9
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:266
    // if (allowedMethod.selector === selectorArg && (!hasCooldown || !onCooldown)) {
    extract 0 4 // on error: Index access is out of bounds
    ==
    bz fullPluginCheck_after_if_else@17
    frame_dig 10
    bz fullPluginCheck_if_body@14
    frame_dig 9
    bnz fullPluginCheck_after_if_else@17

fullPluginCheck_if_body@14:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:268
    // if (hasCooldown) {
    frame_dig 10
    bz fullPluginCheck_after_if_else@16
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:269
    // methods[offset].lastCalled = new arc4.UintN64(Global.round);
    global Round
    itob
    frame_dig 0
    swap
    replace2 12
    frame_dig 1
    dup
    intc_0 // 0
    extract_uint16
    frame_dig 8
    >
    assert // Index access is out of bounds
    frame_dig 4
    pushint 2 // 2
    +
    uncover 2
    replace3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    frame_dig 2
    dup
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    dig 1
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    dig 2
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    extract 16 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:271
    // ...this.plugins(key).value,
    dig 3
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:270-273
    // this.plugins(key).value = new PluginInfo({
    //   ...this.plugins(key).value,
    //   methods: methods.copy()
    // });
    intc 4 // 192
    getbit
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec 4 // 0x001b
    concat
    uncover 2
    concat
    dig 1
    box_del
    pop
    box_put

fullPluginCheck_after_if_else@16:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:277
    // methodAllowed: true,
    intc_1 // 1
    frame_dig 9
    frame_bury 7
    frame_dig 3
    frame_bury 6
    frame_bury 5

fullPluginCheck_after_if_else@6:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:140
    // valid: check.valid && methodCheck.methodAllowed
    frame_dig 11
    bz fullPluginCheck_bool_false@9
    frame_dig 5
    bz fullPluginCheck_bool_false@9
    intc_1 // 1

fullPluginCheck_bool_merge@10:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:137-141
    // return {
    //   ...check,
    //   ...methodCheck,
    //   valid: check.valid && methodCheck.methodAllowed
    // }
    frame_dig 16
    frame_dig 15
    frame_dig 14
    frame_dig 13
    frame_dig 12
    frame_dig 5
    frame_dig 6
    frame_dig 7
    uncover 8
    frame_dig -6
    frame_dig -2
    frame_bury 10
    frame_bury 9
    frame_bury 8
    frame_bury 7
    frame_bury 6
    frame_bury 5
    frame_bury 4
    frame_bury 3
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub

fullPluginCheck_bool_false@9:
    intc_0 // 0
    b fullPluginCheck_bool_merge@10

fullPluginCheck_after_if_else@17:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:284
    // methodAllowed: false,
    intc_0 // 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:285
    // methodHasCooldown: true,
    intc_1 // 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:286
    // methodOnCooldown: true
    dup
    frame_bury 7
    frame_bury 6
    frame_bury 5
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:134
    // methodCheck = this.methodCheck(txn, app, caller, methodOffsets[methodIndex].native);
    b fullPluginCheck_after_if_else@6


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.createApplication(controlledAddress: bytes, admin: bytes) -> void:
createApplication:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:308-309
    // @abimethod({ onCreate: 'require' })
    // createApplication(controlledAddress: arc4.Address, admin: arc4.Address) {
    proto 2 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:314
    // Txn.sender === controlledAddress.native
    txn Sender
    frame_dig -2
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:314-315
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bnz createApplication_bool_true@2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:315
    // || Txn.sender === admin.native,
    txn Sender
    frame_dig -1
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:314-315
    // Txn.sender === controlledAddress.native
    // || Txn.sender === admin.native,
    bz createApplication_bool_false@3

createApplication_bool_true@2:
    intc_1 // 1

createApplication_bool_merge@4:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:313-317
    // assert(
    //   Txn.sender === controlledAddress.native
    //   || Txn.sender === admin.native,
    //   'Sender must be either controlledAddress or admin'
    // );
    assert // Sender must be either controlledAddress or admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:318
    // assert(admin !== controlledAddress);
    frame_dig -1
    frame_dig -2
    !=
    assert
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    bytec_1 // "admin"
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:320
    // this.admin.value = admin.native;
    frame_dig -1
    app_global_put
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:321
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    frame_dig -2
    global ZeroAddress
    ==
    bz createApplication_ternary_false@6
    global CurrentApplicationAddress

createApplication_ternary_merge@7:
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    bytec_2 // "controlled_address"
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:321
    // this.controlledAddress.value = controlledAddress.native === Global.zeroAddress ? Global.currentApplicationAddress : controlledAddress.native;
    swap
    app_global_put
    retsub

createApplication_ternary_false@6:
    frame_dig -2
    b createApplication_ternary_merge@7

createApplication_bool_false@3:
    intc_0 // 0
    b createApplication_bool_merge@4


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_changeAdmin(newAdmin: bytes) -> void:
arc58_changeAdmin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:329
    // arc58_changeAdmin(newAdmin: arc4.Address): void {
    proto 1 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:331
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:331
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    bytec_1 // "admin"
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:332
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_pluginChangeAdmin(plugin: bytes, allowedCaller: bytes, newAdmin: bytes) -> void:
arc58_pluginChangeAdmin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:343
    // arc58_pluginChangeAdmin(plugin: arc4.UintN64, allowedCaller: arc4.Address, newAdmin: arc4.Address): void {
    proto 3 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:345
    // assert(Txn.sender === Application(plugin.native).address, 'Sender must be the plugin');
    txn Sender
    frame_dig -3
    btoi
    dup
    app_params_get AppAddress
    assert // application exists
    uncover 2
    ==
    assert // Sender must be the plugin
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:347
    // this.controlledAddress.value.authAddress === Application(plugin.native).address,
    acct_params_get AcctAuthAddr
    assert // account funded
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:346-349
    // assert(
    //   this.controlledAddress.value.authAddress === Application(plugin.native).address,
    //   'This plugin is not in control of the account'
    // );
    assert // This plugin is not in control of the account
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:351
    // const key = new PluginsKey({ application: plugin, allowedCaller: allowedCaller });
    frame_dig -3
    frame_dig -2
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    swap
    concat
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:355
    // this.plugins(key).exists && this.plugins(key).value.adminPrivileges.native,
    box_len
    bury 1
    bz arc58_pluginChangeAdmin_bool_false@3
    frame_dig 0
    box_get
    assert // Box must have value
    intc 4 // 192
    getbit
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz arc58_pluginChangeAdmin_bool_false@3
    intc_1 // 1

arc58_pluginChangeAdmin_bool_merge@4:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:354-357
    // assert(
    //   this.plugins(key).exists && this.plugins(key).value.adminPrivileges.native,
    //   'This plugin does not have admin privileges'
    // );
    assert // This plugin does not have admin privileges
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    bytec_1 // "admin"
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:359
    // this.admin.value = newAdmin.native;
    frame_dig -1
    app_global_put
    retsub

arc58_pluginChangeAdmin_bool_false@3:
    intc_0 // 0
    b arc58_pluginChangeAdmin_bool_merge@4


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_getAdmin() -> bytes:
arc58_getAdmin:
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:369
    // return new arc4.Address(this.admin.value);
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_verifyAuthAddr() -> void:
arc58_verifyAuthAddr:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:375
    // arc58_verifyAuthAddr(): void {
    proto 0 0
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:376
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr());
    acct_params_get AcctAuthAddr
    assert // account funded
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:295
    // return this.controlledAddress.value === Global.currentApplicationAddress
    global CurrentApplicationAddress
    ==
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:295-297
    // return this.controlledAddress.value === Global.currentApplicationAddress
    //   ? Global.zeroAddress // contract controls itself
    //   : Global.currentApplicationAddress; // contract controls a different account
    bz arc58_verifyAuthAddr_ternary_false@3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:296
    // ? Global.zeroAddress // contract controls itself
    global ZeroAddress

arc58_verifyAuthAddr_ternary_merge@4:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:376
    // assert(this.controlledAddress.value.authAddress === this.getAuthAddr());
    frame_dig 0
    ==
    assert
    retsub

arc58_verifyAuthAddr_ternary_false@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:297
    // : Global.currentApplicationAddress; // contract controls a different account
    global CurrentApplicationAddress
    b arc58_verifyAuthAddr_ternary_merge@4


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyTo(address: bytes, flash: bytes) -> void:
arc58_rekeyTo:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:385
    // arc58_rekeyTo(address: arc4.Address, flash: arc4.Bool): void {
    proto 2 0
    pushbytes ""
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:387
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:387
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:389-397
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:394
    // note: 'rekeying abstracted account',
    pushbytes "rekeying abstracted account"
    itxn_field Note
    frame_dig -2
    itxn_field RekeyTo
    frame_dig -2
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:389-396
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:395
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:389-397
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: address.native,
    //     rekeyTo: address.native,
    //     note: 'rekeying abstracted account',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:399
    // if (flash.native) this.assertRekeysBack();
    frame_dig -1
    intc_0 // 0
    getbit
    bz arc58_rekeyTo_after_if_else@3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:64
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:65
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 0

arc58_rekeyTo_while_top@5:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:65
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    global GroupSize
    <
    bz arc58_rekeyTo_block@10
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:68
    // if (this.txnRekeysBack(txn)) {
    frame_dig 0
    callsub txnRekeysBack
    bz arc58_rekeyTo_after_if_else@8
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:69
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 1

arc58_rekeyTo_block@10:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:74
    // assert(rekeysBack, 'rekey back not found');
    frame_dig 1
    assert // rekey back not found

arc58_rekeyTo_after_if_else@3:
    retsub

arc58_rekeyTo_after_if_else@8:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:65
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 0
    intc_1 // 1
    +
    frame_bury 0
    b arc58_rekeyTo_while_top@5


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_canCall(plugin: bytes, address: bytes, method: bytes) -> uint64:
arc58_canCall:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:410-411
    // @abimethod({ readonly: true })
    // arc58_canCall(plugin: arc4.UintN64, address: arc4.Address, method: arc4.StaticBytes<4>): boolean {
    proto 3 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:412
    // const globalAllowed = this.pluginCallAllowed(plugin, new arc4.Address(Global.zeroAddress), method);
    frame_dig -3
    global ZeroAddress
    frame_dig -1
    callsub pluginCallAllowed
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:413
    // if (globalAllowed) return true;
    bz arc58_canCall_after_if_else@2
    intc_1 // 1
    retsub

arc58_canCall_after_if_else@2:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:415
    // return this.pluginCallAllowed(plugin, address, method);
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub pluginCallAllowed
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToPlugin(plugin: bytes, methodOffsets: bytes) -> bytes:
arc58_rekeyToPlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:427
    // arc58_rekeyToPlugin(plugin: arc4.UintN64, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    proto 2 1
    intc_0 // 0
    pushbytes ""
    dupn 7
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:429
    // this.assertValidGroup(Application(plugin.native), methodOffsets);
    frame_dig -2
    btoi
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:155
    // application: new arc4.UintN64(plugin.id),
    itob
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:154-157
    // const gKey = new PluginsKey({
    //   application: new arc4.UintN64(plugin.id),
    //   allowedCaller: new arc4.Address(Global.zeroAddress)
    // });
    dup
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:156
    // allowedCaller: new arc4.Address(Global.zeroAddress)
    global ZeroAddress
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:154-157
    // const gKey = new PluginsKey({
    //   application: new arc4.UintN64(plugin.id),
    //   allowedCaller: new arc4.Address(Global.zeroAddress)
    // });
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:159
    // const globalCheck = this.pluginCheck(gKey);
    callsub pluginCheck
    cover 7
    cover 6
    pop
    cover 4
    pop
    cover 2
    swap
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:163
    // allowedCaller: new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:161-164
    // const lKey = new PluginsKey({
    //   application: new arc4.UintN64(plugin.id),
    //   allowedCaller: new arc4.Address(Txn.sender)
    // });
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:166
    // const localCheck = this.pluginCheck(lKey);
    callsub pluginCheck
    cover 7
    cover 6
    pop
    cover 4
    pop
    cover 2
    swap
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:168
    // assert(globalCheck.exists || localCheck.exists, 'plugin not found');
    bnz arc58_rekeyToPlugin_bool_true@6
    frame_dig 18
    bz arc58_rekeyToPlugin_bool_false@7

arc58_rekeyToPlugin_bool_true@6:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@8:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:168
    // assert(globalCheck.exists || localCheck.exists, 'plugin not found');
    assert // plugin not found
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:169
    // assert(!globalCheck.expired || !localCheck.expired, 'plugin expired');
    frame_dig 13
    bz arc58_rekeyToPlugin_bool_true@10
    frame_dig 17
    bnz arc58_rekeyToPlugin_bool_false@11

arc58_rekeyToPlugin_bool_true@10:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@12:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:169
    // assert(!globalCheck.expired || !localCheck.expired, 'plugin expired');
    assert // plugin expired
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:170
    // assert(!globalCheck.onCooldown || !localCheck.onCooldown, 'plugin on cooldown');
    frame_dig 12
    bz arc58_rekeyToPlugin_bool_true@14
    frame_dig 16
    bnz arc58_rekeyToPlugin_bool_false@15

arc58_rekeyToPlugin_bool_true@14:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@16:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:170
    // assert(!globalCheck.onCooldown || !localCheck.onCooldown, 'plugin on cooldown');
    assert // plugin on cooldown
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:175
    // assert(globalCheck.valid || localCheck.valid, 'invalid plugin call');
    frame_dig 11
    bnz arc58_rekeyToPlugin_bool_true@18
    frame_dig 15
    bz arc58_rekeyToPlugin_bool_false@19

arc58_rekeyToPlugin_bool_true@18:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@20:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:175
    // assert(globalCheck.valid || localCheck.valid, 'invalid plugin call');
    assert // invalid plugin call
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:177
    // let rekeysBack = false;
    intc_0 // 0
    frame_bury 8
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:178
    // let methodIndex: uint64 = 0;
    intc_0 // 0
    frame_bury 7
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:180
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    txn GroupIndex
    intc_1 // 1
    +
    frame_bury 3
    frame_dig -1
    dup
    frame_bury 0
    frame_bury -1

arc58_rekeyToPlugin_while_top@21:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:180
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 3
    global GroupSize
    <
    bz arc58_rekeyToPlugin_block@43
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:183
    // if (this.txnRekeysBack(txn)) {
    frame_dig 3
    callsub txnRekeysBack
    bz arc58_rekeyToPlugin_after_if_else@24
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:184
    // rekeysBack = true;
    intc_1 // 1
    frame_bury 8

arc58_rekeyToPlugin_block@43:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:241
    // assert(rekeysBack, 'no rekey back found');
    frame_dig 8
    assert // no rekey back found
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:431-439
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/abstracted_account/constants.ts:2
    // export const CONTROLLED_ADDRESS = 'controlled_address'
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_2 // "controlled_address"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:435
    // rekeyTo: Application(plugin.native).address,
    frame_dig 9
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:436
    // note: 'rekeying to plugin app',
    pushbytes "rekeying to plugin app"
    itxn_field Note
    itxn_field RekeyTo
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:431-438
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    intc_1 // 1
    itxn_field TypeEnum
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:437
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:431-439
    // itxn
    //   .payment({
    //     sender: this.controlledAddress.value,
    //     receiver: this.controlledAddress.value,
    //     rekeyTo: Application(plugin.native).address,
    //     note: 'rekeying to plugin app',
    //     fee: 0,
    //   })
    //   .submit();
    itxn_submit
    retsub

arc58_rekeyToPlugin_after_if_else@24:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:188
    // if (txn.type !== TransactionType.ApplicationCall) {
    frame_dig 3
    gtxns TypeEnum
    pushint 6 // 6
    !=
    bz arc58_rekeyToPlugin_after_if_else@26
    frame_dig 0

arc58_rekeyToPlugin_block@41:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:180
    // for (let i: uint64 = (Txn.groupIndex + 1); i < Global.groupSize; i += 1) {
    frame_dig 3
    intc_1 // 1
    +
    frame_bury 3
    frame_bury 0
    b arc58_rekeyToPlugin_while_top@21

arc58_rekeyToPlugin_after_if_else@26:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:192
    // assert(txn.appId.id === plugin.id, 'cannot call other apps during plugin rekey');
    frame_dig 3
    dup
    gtxns ApplicationID
    frame_dig 9
    dup
    cover 3
    ==
    assert // cannot call other apps during plugin rekey
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:193
    // assert(txn.onCompletion === OnCompleteAction.NoOp, 'invalid onComplete');
    dup
    gtxns OnCompletion
    !
    assert // invalid onComplete
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:196
    // assert(txn.numAppArgs > 1, 'no app id provided');
    dup
    gtxns NumAppArgs
    intc_1 // 1
    >
    assert // no app id provided
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:197
    // assert(Application(btoi(txn.appArgs(1))) === Global.currentApplicationId, 'wrong app id');
    dup
    intc_1 // 1
    gtxnsas ApplicationArgs
    btoi
    global CurrentApplicationID
    ==
    assert // wrong app id
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:203
    // Global.zeroAddress,
    global ZeroAddress
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:199-206
    // const globalLoopCheck = this.fullPluginCheck(
    //   gKey,
    //   txn,
    //   plugin,
    //   Global.zeroAddress,
    //   methodOffsets,
    //   methodIndex
    // );
    frame_dig 10
    dig 2
    dig 4
    uncover 3
    frame_dig -1
    frame_dig 7
    dup
    cover 8
    callsub fullPluginCheck
    frame_bury -1
    frame_bury 10
    frame_bury 2
    cover 10
    popn 4
    frame_bury 1
    popn 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:212
    // Txn.sender,
    txn Sender
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:208-215
    // const localLoopCheck = this.fullPluginCheck(
    //   lKey,
    //   txn,
    //   plugin,
    //   Txn.sender,
    //   methodOffsets,
    //   methodIndex
    // );
    frame_dig 14
    uncover 2
    uncover 3
    uncover 3
    frame_dig -1
    uncover 5
    callsub fullPluginCheck
    frame_bury -1
    frame_bury 14
    frame_bury 6
    frame_bury 5
    popn 4
    frame_bury 4
    popn 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:217
    // assert(!globalLoopCheck.methodOnCooldown || !localLoopCheck.methodOnCooldown, 'method on cooldown');
    bz arc58_rekeyToPlugin_bool_true@28
    frame_dig 5
    bnz arc58_rekeyToPlugin_bool_false@29

arc58_rekeyToPlugin_bool_true@28:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@30:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:217
    // assert(!globalLoopCheck.methodOnCooldown || !localLoopCheck.methodOnCooldown, 'method on cooldown');
    assert // method on cooldown
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:218
    // assert(globalLoopCheck.valid || localLoopCheck.valid, 'not allowed');
    frame_dig 2
    bnz arc58_rekeyToPlugin_bool_true@32
    frame_dig 6
    bz arc58_rekeyToPlugin_bool_false@33

arc58_rekeyToPlugin_bool_true@32:
    intc_1 // 1

arc58_rekeyToPlugin_bool_merge@34:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:218
    // assert(globalLoopCheck.valid || localLoopCheck.valid, 'not allowed');
    assert // not allowed
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:224
    // if (globalLoopCheck.valid && globalLoopCheck.hasCooldown) {
    frame_dig 2
    bz arc58_rekeyToPlugin_else_body@37
    frame_dig 1
    bz arc58_rekeyToPlugin_else_body@37
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:227
    // lastCalled: new arc4.UintN64(Global.round),
    global Round
    itob
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    frame_dig 10
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:228
    // methods: this.plugins(gKey).value.methods.copy(),
    dup
    box_get
    assert // Box must have value
    dup
    intc_3 // 25
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:226
    // ...this.plugins(gKey).value,
    dig 1
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:225-229
    // this.plugins(gKey).value = new PluginInfo({
    //   ...this.plugins(gKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(gKey).value.methods.copy(),
    // });
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:226
    // ...this.plugins(gKey).value,
    dig 2
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:225-229
    // this.plugins(gKey).value = new PluginInfo({
    //   ...this.plugins(gKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(gKey).value.methods.copy(),
    // });
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:226
    // ...this.plugins(gKey).value,
    dig 3
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:225-229
    // this.plugins(gKey).value = new PluginInfo({
    //   ...this.plugins(gKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(gKey).value.methods.copy(),
    // });
    intc 4 // 192
    getbit
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    cover 2
    concat
    uncover 4
    concat
    swap
    concat
    bytec 4 // 0x001b
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put

arc58_rekeyToPlugin_after_if_else@40:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:238
    // methodIndex += 1;
    frame_dig 7
    intc_1 // 1
    +
    frame_bury 7
    frame_dig -1
    b arc58_rekeyToPlugin_block@41

arc58_rekeyToPlugin_else_body@37:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:230
    // } else if (localLoopCheck.valid && localLoopCheck.hasCooldown) {
    frame_dig 6
    bz arc58_rekeyToPlugin_after_if_else@40
    frame_dig 4
    bz arc58_rekeyToPlugin_after_if_else@40
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:233
    // lastCalled: new arc4.UintN64(Global.round),
    global Round
    itob
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    frame_dig 14
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:234
    // methods: this.plugins(lKey).value.methods.copy(),
    dup
    box_get
    assert // Box must have value
    dup
    intc_3 // 25
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:232
    // ...this.plugins(lKey).value,
    dig 1
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:231-235
    // this.plugins(lKey).value = new PluginInfo({
    //   ...this.plugins(lKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(lKey).value.methods.copy(),
    // })
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:232
    // ...this.plugins(lKey).value,
    dig 2
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:231-235
    // this.plugins(lKey).value = new PluginInfo({
    //   ...this.plugins(lKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(lKey).value.methods.copy(),
    // })
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:232
    // ...this.plugins(lKey).value,
    dig 3
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:231-235
    // this.plugins(lKey).value = new PluginInfo({
    //   ...this.plugins(lKey).value,
    //   lastCalled: new arc4.UintN64(Global.round),
    //   methods: this.plugins(lKey).value.methods.copy(),
    // })
    intc 4 // 192
    getbit
    bytec_3 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    cover 2
    concat
    uncover 4
    concat
    swap
    concat
    bytec 4 // 0x001b
    concat
    swap
    concat
    dig 1
    box_del
    pop
    box_put
    b arc58_rekeyToPlugin_after_if_else@40

arc58_rekeyToPlugin_bool_false@33:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@34

arc58_rekeyToPlugin_bool_false@29:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@30

arc58_rekeyToPlugin_bool_false@19:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@20

arc58_rekeyToPlugin_bool_false@15:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@16

arc58_rekeyToPlugin_bool_false@11:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@12

arc58_rekeyToPlugin_bool_false@7:
    intc_0 // 0
    b arc58_rekeyToPlugin_bool_merge@8


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_rekeyToNamedPlugin(name: bytes, methodOffsets: bytes) -> void:
arc58_rekeyToNamedPlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:451
    // arc58_rekeyToNamedPlugin(name: string, methodOffsets: arc4.DynamicArray<arc4.UintN64>): void {
    proto 2 0
    // smart_contracts/abstracted_account/constants.ts:5
    // export const NAMED_PLUGINS_BOX_PREFIX = 'n'
    bytec 6 // "n"
    frame_dig -2
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:452
    // this.arc58_rekeyToPlugin(this.namedPlugins(name).value.application, methodOffsets);
    box_get
    assert // Box must have value
    extract 0 8 // on error: Index access is out of bounds
    frame_dig -1
    callsub arc58_rekeyToPlugin
    frame_bury -1
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_addPlugin(app: bytes, allowedCaller: bytes, lastValidRound: bytes, cooldown: bytes, adminPrivileges: bytes, methods: bytes) -> void:
arc58_addPlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:467-474
    // arc58_addPlugin(
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    proto 6 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:476
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:476
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:477
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -6
    frame_dig -5
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:479
    // let methodInfos = new arc4.DynamicArray<MethodInfo>();
    bytec 9 // 0x0000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:480
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0

arc58_addPlugin_while_top@1:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:480
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz arc58_addPlugin_after_while@3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:481-485
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    frame_dig 1
    extract 2 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:482
    // selector: methods[i].selector,
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 3
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 4 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:483
    // cooldown: methods[i].cooldown,
    swap
    extract 4 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:481-485
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:484
    // lastCalled: new arc4.UintN64(),
    bytec 5 // 0x0000000000000000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:481-485
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    concat
    concat
    dup
    len
    intc_2 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:480
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 2
    b arc58_addPlugin_while_top@1

arc58_addPlugin_after_while@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:488-494
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // });
    frame_dig -4
    frame_dig -3
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:491
    // lastCalled: new arc4.UintN64(),
    bytec 5 // 0x0000000000000000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:488-494
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // });
    concat
    frame_dig -2
    concat
    bytec 4 // 0x001b
    concat
    frame_dig 1
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:488-494
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // });
    dup
    box_del
    pop
    swap
    box_put
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_removePlugin(app: bytes, allowedCaller: bytes) -> void:
arc58_removePlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:505
    // arc58_removePlugin(app: arc4.UintN64, allowedCaller: arc4.Address): void {
    proto 2 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:507
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:507
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:509
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -2
    frame_dig -1
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    swap
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:510
    // assert(this.plugins(key).exists, 'plugin does not exist');
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:511
    // this.plugins(key).delete();
    box_del
    pop
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_addNamedPlugin(name: bytes, app: bytes, allowedCaller: bytes, lastValidRound: bytes, cooldown: bytes, adminPrivileges: bytes, methods: bytes) -> void:
arc58_addNamedPlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:527-535
    // arc58_addNamedPlugin(
    //   name: arc4.Str,
    //   app: arc4.UintN64,
    //   allowedCaller: arc4.Address,
    //   lastValidRound: arc4.UintN64,
    //   cooldown: arc4.UintN64,
    //   adminPrivileges: arc4.Bool,
    //   methods: arc4.DynamicArray<MethodRestriction>,
    // ): void {
    proto 7 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:537
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:537
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:538
    // assert(!this.namedPlugins(name.native).exists);
    frame_dig -7
    extract 2 0
    // smart_contracts/abstracted_account/constants.ts:5
    // export const NAMED_PLUGINS_BOX_PREFIX = 'n'
    bytec 6 // "n"
    swap
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:538
    // assert(!this.namedPlugins(name.native).exists);
    dup
    box_len
    bury 1
    !
    assert
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:540
    // const key = new PluginsKey({ application: app, allowedCaller: allowedCaller });
    frame_dig -6
    frame_dig -5
    concat
    dup
    cover 2
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:541
    // this.namedPlugins(name.native).value = key.copy();
    box_put
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:543
    // let methodInfos = new arc4.DynamicArray<MethodInfo>();
    bytec 9 // 0x0000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:544
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_0 // 0

arc58_addNamedPlugin_while_top@1:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:544
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_dig 2
    >
    bz arc58_addNamedPlugin_after_while@3
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:545-549
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    frame_dig 1
    extract 2 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:546
    // selector: methods[i].selector,
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 3
    pushint 12 // 12
    *
    pushint 12 // 12
    extract3 // on error: Index access is out of bounds
    dup
    extract 0 4 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:547
    // cooldown: methods[i].cooldown,
    swap
    extract 4 8 // on error: Index access is out of bounds
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:545-549
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:548
    // lastCalled: new arc4.UintN64(),
    bytec 5 // 0x0000000000000000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:545-549
    // methodInfos.push(new MethodInfo({
    //   selector: methods[i].selector,
    //   cooldown: methods[i].cooldown,
    //   lastCalled: new arc4.UintN64(),
    // }));
    concat
    concat
    dup
    len
    intc_2 // 20
    /
    itob
    extract 6 2
    swap
    concat
    frame_bury 1
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:544
    // for (let i: uint64 = 0; i < methods.length; i += 1) {
    intc_1 // 1
    +
    frame_bury 2
    b arc58_addNamedPlugin_while_top@1

arc58_addNamedPlugin_after_while@3:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:552-558
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // })
    frame_dig -4
    frame_dig -3
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:555
    // lastCalled: new arc4.UintN64(),
    bytec 5 // 0x0000000000000000
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:552-558
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // })
    concat
    frame_dig -2
    concat
    bytec 4 // 0x001b
    concat
    frame_dig 1
    concat
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    frame_dig 0
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:552-558
    // this.plugins(key).value = new PluginInfo({
    //   lastValidRound: lastValidRound,
    //   cooldown: cooldown,
    //   lastCalled: new arc4.UintN64(),
    //   adminPrivileges: adminPrivileges,
    //   methods: methodInfos.copy(),
    // })
    dup
    box_del
    pop
    swap
    box_put
    retsub


// smart_contracts/abstracted_account/abstracted_account.algo.ts::AbstractedAccount.arc58_removeNamedPlugin(name: bytes) -> void:
arc58_removeNamedPlugin:
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:567
    // arc58_removeNamedPlugin(name: arc4.Str): void {
    proto 1 0
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:569
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    txn Sender
    // smart_contracts/abstracted_account/constants.ts:1
    // export const ADMIN_KEY = 'admin'
    intc_0 // 0
    bytec_1 // "admin"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:569
    // assert(Txn.sender === this.admin.value, 'Sender must be the admin');
    ==
    assert // Sender must be the admin
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:570
    // assert(this.namedPlugins(name.native).exists, 'plugin does not exist');
    frame_dig -1
    extract 2 0
    // smart_contracts/abstracted_account/constants.ts:5
    // export const NAMED_PLUGINS_BOX_PREFIX = 'n'
    bytec 6 // "n"
    swap
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:570
    // assert(this.namedPlugins(name.native).exists, 'plugin does not exist');
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:571
    // const app = this.namedPlugins(name.native).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/abstracted_account/constants.ts:4
    // export const PLUGINS_BOX_PREFIX = 'p'
    bytec_0 // "p"
    swap
    concat
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:572
    // assert(this.plugins(app).exists, 'plugin does not exist');
    dup
    box_len
    bury 1
    assert // plugin does not exist
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:574
    // this.namedPlugins(name.native).delete();
    swap
    box_del
    pop
    // smart_contracts/abstracted_account/abstracted_account.algo.ts:575
    // this.plugins(app).delete();
    box_del
    pop
    retsub
